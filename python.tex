\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\usepackage{listings, jlisting}
\renewcommand{\lstlistingname}{リスト}
\lstset{
%language = R,
%language = C++,   
breaklines = true,
numbers = left,
frame = tbrl,
tabsize = 4,
basicstyle =\ttfamily,
captionpos = t
}
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or eps§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amssymb}

%SetFonts

%SetFonts


\title{Python}
\author{Akihiro Minamino}
%\date{}							% Activate to display a given date or no date

\begin{document}
\maketitle
\section{リテラル}
リテラルとは、Pythonのプログラムに直接記述された値です。
以下の種類がある。

\subsection{組み込み定数}
\begin{itemize}
\item True: 真を表すbool型の値。整数に変換すると1になる。
\item Flase: 偽を表すbool型の値。整数に変換すると0になる。
\item None: 存在しないことを表すNoneType型の値。
\item その他の組み込み定数（NotImplementedなど）
\end{itemize}

\subsection{文字列リテラル}
\begin{itemize}
\item シングルクォーテーションまたはダブルクォーテーションで囲む。改行を直接含めたいといは、三重引用符（三重シングルクォーテーションまたは三重ダブルクォーテーション）を使う。
\end{itemize}

\subsection{数値リテラル}
\begin{itemize}
\item 整数や浮動小数点数などの数字。
\end{itemize}

\subsection{その他}
\begin{itemize}
\item リスト
\item タプル
\item 辞書
\item 集合
\end{itemize}


\section{変数}
\subsection{変数、名前、オブジェクト}
Python変数の重要なポイントは、変数はただの名前だということである。
データをいれているオブジェクトに名前を付けるだけである。
名前は値自体ではなく値の参照である。
名前は、オブジェクトに貼るポストイットのようなものである。

\subsection{数値}
Pythonの数字の並びは、リテラル\footnote{リテラルとは、プログラムのソースコードにおいて使用される、数値や文字列を直接に記述した定数のことである。変数の対義語であり、変更されないことを前提とした値である。}の整数と見なされる。\\
　\\
Pythonでは、=記号の右辺の式がまず計算され、次に左辺の変数に代入が行われる。

\subsection{基数}
整数は、プレフィックスで基数を指定しない限り、10進（基数10）と見なされる。
基数は、「桁上り」しなければならなくなるまで、何個の数字を使えるかを示す。\\
Pythonでは、10進以外に3種類の基数を使ってリテラル整数を表す。
\begin{itemize}
\item 0bは2進（基数2）
\item 0oは8進（基数8）
\item 0xは16進（基数16）
\end{itemize}
インタープリターは、10進整数として、整数を表示する。
\begin{lstlisting}
>>> 10
10
>>> 0b10
2
>>> 0x10
16
\end{lstlisting}

\subsection{型の変換}
Pythonの整数以外のデータ型を整数に変換するには、int()関数を使う。
この関数は整数部だけを残し、小数部を切り捨てる。\\
　\\
int()は、数字でできた文字列を整数に変換する。しかし、小数点や指数部を含む文字列は処理しない。
\begin{lstlisting}
>>> int('98.6')
ValueError: ...
>>> int('1.0e4')
ValueError: ...
\end{lstlisting}
　\\
他のデータ型の値をfloatに変換するには、\verb|float()|関数を使う。
\begin{lstlisting}
>>> float(True)
1.0
>>> float(False)
0.0
>>> float(98)
98.0
>>> float('99')
99.0
>>> float('98.6')
98.6
>>> float('-1.5')
-1.5
>>> float('1.0e4')
10000.0
\end{lstlisting}


\subsection{文字列}
文字列は、文字のシーケンスである。\\
 \\
 他の言語と異なり、Pythonの文字列はイミュータブルである。
 つまり、文字列をその場で書き換えることができない。\\
 
 \subsubsection{クォートを使った作成}
Python文字列は、シングルクォートかダブルクォートで文字を囲んで作る。
どちらのクォートを使っても、Pythonはまったく同じように扱う。
2種類のクォート文字を使えるようにしている理由は、クォート文字を含む文字列を作りやすくするためである。ダブルクォートで文字列を作るときは、文字列内にシングルクォートを入れることができ、シングルクォートで文字列を作るときは、文字列内にダブルクォートを入れることができる。
\begin{lstlisting}
>>> "Nay,' said the naysayer."
"Nay,' said the naysayer."
>>> 'The rare double quote in captivity: ".'
'The rare double quote in captivity: ".'
>>> 'A "two by four" is actually 1 1/2" X 3 1/2".'
'A "two by four" is actually 1 1/2" X 3 1/2".'
>>> "'There's the man that shot my paw!' cried the limping hound."
"'There's the man that shot my paw!' cried the limping hound."
\end{lstlisting}
3個のシングルクォート（\verb|'''|）や3個のダブルクォート（\verb|"""|）を使うこともできる。
\begin{lstlisting}
>>> '''Boom!'''
'Boom'
>>> """Eek!"""
'Eek!'
\end{lstlisting}
トリプルクォートは、次のような複数行文字列を作るために使われる。
\begin{lstlisting}
>>> poem = '''There was a Young Lady of Norway,
... Who casually sat in a doorway;
... When the door squeezed her flat,
... She exclaimed, "What of that?"
... This courageous Young Lady of Norway.'''
>>> print(poem)
There was a Young Lady of Norway,
Who casually sat in a doorway;
When the door squeezed her flat,
She exclaimed, "What of that?"
This courageous Young Lady of Norway.
\end{lstlisting}
トリプルクォートのなかに複数行の文字列を入れると、その文字列には
改行文字も残される。先頭や末尾にスペースがある場合、それらも残る。
\begin{lstlisting}
>>> poem2 = '''I do not like thee, Doctor Fell.
...     The reason why, I cannot tell.
...     But this I know, and know full well:
...     I do not like thee, Doctor Fell.
... '''
>>> print(poem2)
I do not like thee, Doctor Fell.
    The reason why, I cannot tell.
    But this I know, and know full well:
    I do not like thee, Doctor Fell.

>>> poem2
'I do not like thee, Doctor Fell.\n    The reason why, I cannot tell.\n    But this I know, and know full well:\n    I do not like thee, Doctor Fell.\nprint(poem2)\n'
\end{lstlisting}
\verb|print()|は文字列からクォートを取り除き、表示する項目の間にスペースを追加し、末尾に改行を追加し、文字列の内容を表示する。
　\\
文字列には空文字列がある。文字がひとつも含まれていない文字列だが、完全に有効な文字列として扱われる。空文字は、クォートを使って以下のように作る。
\begin{lstlisting}
>>> ''
''
>>> ""
''
>>> ''''''
''
>>> """"""
''
>>>
\end{lstlisting}
空文字は、他の文字列から新しく文字列を組み立てたいときに、まず白紙のノートが必要になる、
\begin{lstlisting}
>>> bottles = 99
>>> base = ''
>>> base += 'current inventory: ' #在庫
>>> base += str(bottles)
>>> base
'current inventory: 99'
\end{lstlisting}

\subsubsection{str()を使った型変換}
\verb|str()|関数を使うと、他のデータ型を文字列に変換できる。
\begin{lstlisting}
>>> str(98.6)
'98.6'
>>> str(1.0e4)
'10000.0'
>>> str(True)
'True'
\end{lstlisting}

\subsubsection{$\backslash$によるエスケープ}
特定の文字の前にバックスラッシュ（$\backslash$）を入れると、特別な意味になる。
もっともよく使われるエスケープシーケンスは、改行の意味になる\verb|\n|だ。
\begin{lstlisting}
>>> palindrome = 'A man,\nA plan,\nA canal:\nPanama.'
>>> print(palindrome)
A man,
A plan,
A canal:
Panama.
\end{lstlisting}
テキストの位置を揃えるために\verb|\t|というエスケープシーケンスもよく使う。
\begin{lstlisting}
>>> print('\tabc')
	abc
>>> print('a\tbc')
a	bc
>>> print('ab\tc')
ab	c
>>> print('abc\t')
abc
\end{lstlisting}
最後の文字列の末尾にタブ文字が含まれるが、目には見えない。\\
　\\
文字列を囲むために使っているシングルクォート、ダブルクォートを文字列内でもリテラルとして使いたい場合は、\verb|\'|と\verb|\"|が必要になる。
\begin{lstlisting}
>>> testimony = "\"I did nothing!\" he said. \"Not that either! Or the other thing.\""
>>> print(testimony)
"I did nothing!" he said. "Not that either! Or the other thing."
>>> fact = "The world's largest rubber duck was 54'2\" by 65'7\" by 105'"
>>> print(fact)
The world's largest rubber duck was 54'2" by 65'7" by 105'
\end{lstlisting}
リテラルのバックスラッシュが必要な場合には、バックスラッシュをふたつ重ねる。
\begin{lstlisting}
>>> speech = 'Today we honor our friend, the backslash: \\.'
>>> print(speech)
Today we honor our friend, the backslash: \.
\end{lstlisting}

\subsubsection{+による連結}
Pythonでは、+演算子を使えば、リテラル文字列、文字列変数を連結できる。
\begin{lstlisting}
>>> 'Release the kraken! ' + 'At once!'
'Release the kraken! At once!'
\end{lstlisting}
リテラル文字列の場合は、順に並べるだけでも連絡できる（文字列変数はできない）。
\begin{lstlisting}
>>> "My word! " "A gentleman caller!"
'My word! A gentleman caller!'
\end{lstlisting}
文字列の連結では、Pythonは自動的にスペースを追加しない。
それに対し、\verb|print()|関数は、各引数の間にはスペースを挿入し、末尾に改行を追加する。
\begin{lstlisting}
>>> a = 'Duck.'
>>> b = a
>>> c = 'Grey Duck!'
>>> a + b + c
'Duck.Duck.Grey Duck!'
>>> print(a, b, c)
Duck. Duck. Grey Duck!
\end{lstlisting}

\subsubsection{*による繰り返し}
*演算子を使うと、文字列を繰り返すことができる。
\begin{lstlisting}
>>> a = 'Duck.'
>>> start = 'Na ' * 4 + '\n'
>>> middle = 'Hey ' * 3 + '\n'
>>> end = 'Goodbye.'
>>> print(start + start + middle + end)
Na Na Na Na 
Na Na Na Na 
Hey Hey Hey 
Goodbye.
\end{lstlisting}

\subsubsection{[ ]による文字の抽出}
文字列のなかのひとつの文字を取り出したいときは、文字列名の後ろに[ ]で囲んだ
文字のオフセットを各。先頭の文字（もっとも左）のオフセットは0、その右が1と数える。
末尾（もっとも右）の文字のオフセットは-1えも指定できる。
右端の左は-2、されにその左は-3のように続く。
\begin{lstlisting}
>>> letters = 'abcdefghijklmnopqrstuvwxyz'
>>> letters[0]
'a'
>>> letters[1]
'b'
>>> letters[-1]
'z'
>>> letters[-2]
'y'
>>> letters[25]
'z'
>>> letters[5]
\end{lstlisting}
文字列の長さ以上のオフセットを指定すると、例外が起きる。
\begin{lstlisting}
>>> letters[100]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module
\end{lstlisting}
このインデックス参照は、他のシーケンス型（リストやタプル）でも機能する。\\
 \\
 文字列はイミュータブルなので、文字列に直接文字を挿入したり、
 指定したインデックスの位置の文字を書き換えたりすることはできない。
 
\subsubsection{[start:end:step]によるスライス}
スライスを使えば、文字列から部分文字列（文字列の一部）を取り出すことができる。
スライスは、[ ]と先頭オフセット（start）、末尾オフセット（end）、ステップ（step）
で定義する。
\begin{itemize}
\item \verb|[ : ]|は、先頭から末尾までのシーケンス全体を抽出する。
\item \verb|[ start: ]|は、\verb|start|オフセットから末尾までのシーケンスを抽出する。
\item \verb|[ :end ]|は、先頭から\verb|end-1|オフセットまでのシーケンスを抽出する。
\item \verb|[ start:end ]|は、\verb|start|オフセットから\verb|end-1|オフセットまでのシーケンスを抽出する。
\item \verb|[ start:end:step ]|は、\verb|step|文字毎に\verb|start|オフセットから\verb|end-1|オフセットまでのシーケンスを抽出する。
\end{itemize}
\begin{lstlisting}
>>> letters = 'abcdefghijklmnopqrstuvwxyz'
>>> letters[ : ]
'abcdefghijklmnopqrstuvwxyz'
>>> letters[20:]
'uvwxyz'
>>> letters[10:]
'klmnopqrstuvwxyz'
>>> letters[12:15]
'mno'
>>> letters[-3:]
'xyz'
>>> letters[18:-3]
'stuvw'
>>> letters[-6:-3]
'uvw'
>>> letters[::7]
'ahov'
>>> letters[4:20:3]
'ehknqt'
>>> letters[19::4]
'tx'
>>> letters[:21:5]
'afkpu'
\end{lstlisting}
Pythonでは、末尾の指定は実際のオフセットよりもひとつ先でなければならない。\\
 \\
 ステップサイズとして負数を指定すると、この便利なスライスは逆にステップしていく。
 \begin{lstlisting}
>>> letters = 'abcdefghijklmnopqrstuvwxyz'
>>> letters[-1::-1]
'zyxwvutsrqponmlkjihgfedcba'
>>> letters[::-1]
'zyxwvutsrqponmlkjihgfedcba'
 \end{lstlisting}
 
 \subsubsection{len()による長さの取得}
 Pythonの組み込み関数\verb|len()|は、文字列内の文字数を数える。
 \begin{lstlisting}
 >>> letters = 'abcdefghijklmnopqrstuvwxyz'
>>> len(letters)
26
>>> empty = ''
>>> len(empty)
0
 \end{lstlisting}
 
 \subsubsection{split()による分割}
 文字列専用関数を使うときには、文字列の名前をタイプしてからドット、さらに関数名をタイプし、関数が必要とする引数を指定する。つまり、\verb|string.function(arguments)|という形式である。\\
 文字列関数\verb|split()|は、セパレータに基づいて文字列を分割し、部分文字列のリストを作る。
 \begin{lstlisting}
>>> todos = 'get gloves, get mask, get cat vitamins, call ambulance'
>>> todos.split(',')
['get gloves', ' get mask', ' get cat vitamins', ' call ambulance']
 \end{lstlisting}
 セパレータを指定していない\verb|split()|は、セパレーターとして空白文字(改行、スペース、タブ)のシーケンスを使う。
 \begin{lstlisting}
>>> todos.split()
['get', 'gloves,', 'get', 'mask,', 'get', 'cat', 'vitamins,', 'call', 'ambulance']
\end{lstlisting}
 Pythonは括弧の有無で関数呼び出しかどうかを判断しているので、引数なしで\verb|split|を呼び出すときでも括弧は必要。
 
 \subsection{join()による結合}
 \verb|join()|関数は、まず文字列に「糊としてはさむ文字列」を指定してから、結合する文字列のリストを指定する。
 次の例では、カンマとスペースを間に挟んでリストに含まれている名前を結合する。
  \begin{lstlisting}
  >>> crypto_list = ['Yeti', 'Bigfoot', 'Loch Ness Monster']
>>> crypto_string = ', '.join(crypto_list)
>>> print('Found and signing book deals;', crypto_string)
Found and signing book deals; Yeti, Bigfoot, Loch Ness Monster
  \end{lstlisting}
  
  \subsection{文字列操作}
  次の詩を例として使う。
   \begin{lstlisting}
 >>> poem = '''All that doth flow we cannot liquid name Or else would fire and water be the same; But that is liquid which is moist and wet Fire that property can never get. Then 'tis not cold that doth the fire put out But 'tis the wet that makes it die, no doubt.'''
   \end{lstlisting}
  最初の13字（オフセット0から12）を取り出すには、
 \begin{lstlisting}
 >>> poem[:13]
 'All that doth'
 \end{lstlisting}
 とすればよい。\\
 この詩に含まれる文字数を調べるには、
 \begin{lstlisting}
 >>> len(poem)
250
 \end{lstlisting}
 とすればよい。\\
 
 p.79から
 

\end{document}  